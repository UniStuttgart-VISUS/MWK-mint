
#include <glad/glad.h>
#include <GLFW/glfw3.h>
#define GLM_FORCE_CTOR_INIT
#define GLM_FORCE_EXPLICIT_CTOR
#include <glm/glm.hpp> // vec2, vec3, mat4, radians
#include <glm/ext.hpp> // perspective, translate, rotate
#include <glm/gtx/transform.hpp> // rotate in degrees around axis

#include <iostream>
#include <vector>

#include <interop.hpp>

glm::vec4 toGlm(const mint::vec4& v) {
	return glm::vec4{v.x, v.y, v.z, v.w};
}
mint::vec4 toInterop(const glm::vec3& v) {
	return mint::vec4{v.x, v.y, v.z, 0.0f};
}
glm::mat4 toGlm(const mint::mat4& m) {
	return glm::mat4{
		toGlm(m.data[0]),
		toGlm(m.data[1]),
		toGlm(m.data[2]),
		toGlm(m.data[3])
	};
}

static void glfw_error_callback(int error, const char* description)
{
	std::cout << "GLFW Error " << error << ": " << description << std::endl;
}

static void glfw_key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
	if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)
		glfwSetWindowShouldClose(window, GLFW_TRUE);
}

void APIENTRY opengl_debug_message_callback(
	GLenum source,
	GLenum type,
	GLuint id,
	GLenum severity,
	GLsizei length,
	const GLchar* message,
	const void* userParam)
{
	/* Message Sources
		Source enum                      Generated by
		GL_DEBUG_SOURCE_API              Calls to the OpenGL API
		GL_DEBUG_SOURCE_WINDOW_SYSTEM    Calls to a window - system API
		GL_DEBUG_SOURCE_SHADER_COMPILER  A compiler for a shading language
		GL_DEBUG_SOURCE_THIRD_PARTY      An application associated with OpenGL
		GL_DEBUG_SOURCE_APPLICATION      Generated by the user of this application
		GL_DEBUG_SOURCE_OTHER            Some source that isn't one of these
	*/
	/* Message Types
		Type enum                          Meaning
		GL_DEBUG_TYPE_ERROR                An error, typically from the API
		GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR  Some behavior marked deprecated has been used
		GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR   Something has invoked undefined behavior
		GL_DEBUG_TYPE_PORTABILITY          Some functionality the user relies upon is not portable
		GL_DEBUG_TYPE_PERFORMANCE          Code has triggered possible performance issues
		GL_DEBUG_TYPE_MARKER               Command stream annotation
		GL_DEBUG_TYPE_PUSH_GROUP           Group pushing
		GL_DEBUG_TYPE_POP_GROUP            foo
		GL_DEBUG_TYPE_OTHER                Some type that isn't one of these
	*/
	/* Message Severity
		Severity enum                    Meaning
		GL_DEBUG_SEVERITY_HIGH           All OpenGL Errors, shader compilation / linking errors, or highly - dangerous undefined behavior
		GL_DEBUG_SEVERITY_MEDIUM         Major performance warnings, shader compilation / linking warnings, or the use of deprecated functionality
		GL_DEBUG_SEVERITY_LOW            Redundant state change performance warning, or unimportant undefined behavior
		GL_DEBUG_SEVERITY_NOTIFICATION   Anything that isn't an error or performance issue.
	*/
	if (source == GL_DEBUG_SOURCE_API || source == GL_DEBUG_SOURCE_SHADER_COMPILER)
		if (type == GL_DEBUG_TYPE_ERROR || type == GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR || type == GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR)
			if (severity == GL_DEBUG_SEVERITY_HIGH || severity == GL_DEBUG_SEVERITY_MEDIUM)
				std::cout << "OpenGL Error: " << message << std::endl;
}

struct Vertex
{
	float x, y, z;
	float r, g, b;
};

struct RenderVertices {
	GLuint vertex_array = 0, vertex_buffer = 0;
	GLuint element_array = 0;

	void init(const std::vector<Vertex>& vertices) {
		glGenVertexArrays(1, &vertex_array);
		glBindVertexArray(vertex_array);
		glGenBuffers(1, &vertex_buffer);
		glGenBuffers(1, &element_array);
		glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
		glBufferData(GL_ARRAY_BUFFER, sizeof(Vertex) * vertices.size(), vertices.data(), GL_STATIC_DRAW);
		unbind();
	}

	void setElements(const std::vector<unsigned int>& elements) {
		bind();
		glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(unsigned int) * elements.size(), elements.data(), GL_STATIC_DRAW);
		unbind();
	}

	void bind() {
		glBindVertexArray(vertex_array);
		glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, element_array);
	}
	void unbind() {
		glBindVertexArray(0);
		glBindBuffer(GL_ARRAY_BUFFER, 0);
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
	}

	void destroy() {
		unbind();
		glDeleteVertexArrays(1, &vertex_array);
		glDeleteBuffers(1, &vertex_buffer);
		glDeleteBuffers(1, &element_array);
		vertex_array = 0;
		vertex_buffer = 0;
		element_array = 0;
	}
};

const char *vertex_shader_source =
R"(
	#version 400

	//in int gl_VertexID;

	const vec4 unitQuad[4] =
	vec4[](
		vec4(-1.0f, 1.0f, 0.0f, 1.0f),
		vec4(-1.0f,-1.0f, 0.0f, 1.0f),
		vec4( 1.0f, 1.0f, 0.0f, 1.0f),
		vec4( 1.0f,-1.0f, 0.0f, 1.0f)
	);
	
	void main()
	{
	    gl_Position = unitQuad[gl_VertexID];
	}
)";

const char *fragment_shader_source =
R"(
	#version 400

	in vec4 gl_FragCoord;

	out vec4 FragColor;

	uniform sampler2D texture_in;
	uniform ivec2 texture_size;
	uniform int meta_data;

	void main()
	{
		FragColor = texture(texture_in, vec2(gl_FragCoord.xy) / vec2(texture_size.xy));
	}
)";

int main(void)
{
	GLFWwindow* window;
	GLuint vertex_shader, fragment_shader, program;
	glfwSetErrorCallback(glfw_error_callback);
	if (!glfwInit())
		exit(EXIT_FAILURE);
	glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GLFW_TRUE);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	int initialWidth = 640;
	int initialHeight = 480;
	window = glfwCreateWindow(initialWidth, initialHeight, "mint steering example", NULL, NULL);
	if (!window)
	{
		glfwTerminate();
		exit(EXIT_FAILURE);
	}
	glfwSetKeyCallback(window, glfw_key_callback);
	glfwMakeContextCurrent(window);
	glfwSwapInterval(0);
	gladLoadGLLoader((GLADloadproc) glfwGetProcAddress);

	glEnable(GL_DEBUG_OUTPUT);
	glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
	glDebugMessageCallback(opengl_debug_message_callback, nullptr);

	glEnable(GL_DEPTH_TEST);
	glDepthFunc(GL_LESS);
	glClearDepth(1.0f);
	glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
	glDisable(GL_CULL_FACE);

	// https://www.khronos.org/opengl/wiki/Shader_Compilation
	auto check_shader_compilation = [](auto& name, auto& shader) {
		GLint isCompiled = 0;
		glGetShaderiv(shader, GL_COMPILE_STATUS, &isCompiled);
		if(isCompiled == GL_FALSE)
		{
			GLint maxLength = 0;
			glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &maxLength);
		
			std::vector<GLchar> errorLog(maxLength);
			glGetShaderInfoLog(shader, maxLength, &maxLength, &errorLog[0]);

			std::cout << "Shader Compilation Error " << name << ": " << std::string{(char*)errorLog.data()} << std::endl;
		
			glDeleteShader(shader);

			std::exit(EXIT_FAILURE);
		}
	};

	vertex_shader = glCreateShader(GL_VERTEX_SHADER);
	glShaderSource(vertex_shader, 1, &vertex_shader_source, NULL);
	glCompileShader(vertex_shader);
	check_shader_compilation("Vertex", vertex_shader);
	fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
	glShaderSource(fragment_shader, 1, &fragment_shader_source, NULL);
	glCompileShader(fragment_shader);
	check_shader_compilation("Fragment", fragment_shader);
	program = glCreateProgram();
	glAttachShader(program, vertex_shader);
	glAttachShader(program, fragment_shader);
	glLinkProgram(program);

	glDeleteShader(vertex_shader);
	glDeleteShader(fragment_shader);
	
	GLuint uniform_texture_location = glGetUniformLocation(program, "texture_in"); // sampler2D
	GLuint uniform_texture_size_location = glGetUniformLocation(program, "texture_size"); // ivec2

	std::vector<Vertex> quadVertices;
	RenderVertices quad;
	quad.init(quadVertices);
	quad.bind();
	//registerVertexAttributes();
	quad.unbind();

	mint::init(mint::Role::Steering, mint::Protocol::IPC);

	mint::glFramebuffer fbo;
	fbo.init();

	mint::TextureReceiver texture_receiver;
	texture_receiver.init(mint::ImageType::SingleStereo);

	mint::DataSender data_sender;
	data_sender.start();

	auto cameraProjection = mint::CameraProjection(); // "CameraProjection"
	auto stereoCameraView = mint::StereoCameraView(); // "StereoCameraViewRelative"

	mint::DataReceiver bboxReceiver;
	bboxReceiver.start("BoundingBoxCorners");
	auto bboxCorners = mint::BoundingBoxCorners{
		mint::vec4{0.0f, 0.0f, 0.0f , 1.0f},
		mint::vec4{1.0f, 1.0f, 1.0f , 1.0f},
	};

	const auto cam_up = glm::vec3{ 0.0f, 1.0f, 0.0f };

	mint::CameraView defaultCameraView;
	defaultCameraView.eyePos    = toInterop(glm::vec3{ 0.0f, 0.0f, 3.0f });
	defaultCameraView.lookAtPos = toInterop(glm::vec3{ 0.0f });
	defaultCameraView.camUpDir  = toInterop(cam_up);

	auto get_camera_view = [&](mint::BoundingBoxCorners& bbox) -> mint::CameraView {
		auto diagonal = bbox.diagonal();
		auto center = diagonal * 0.5f + bbox.min;

		mint::CameraView view;

		view.eyePos    = center + diagonal*0.5f;
		view.lookAtPos = center;
		view.camUpDir  = toInterop(cam_up);

		return view;
	};

	float fovy = 90.f;
	float aspect_ratio = initialWidth/ (float) initialHeight;
	float near_p = 0.1f;
	float far_p = 10.0f;

	auto projection = glm::perspective(fovy, aspect_ratio, near_p, far_p);

	int width = 800, height = 600;

	mint::uint frame_id = 0;

	while (!glfwWindowShouldClose(window))
	{
		frame_id++;

		glfwGetFramebufferSize(window, &width, &height);

		aspect_ratio = width / (float) height;
		// default framebuffer
		glViewport(0, 0, width, height);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		cameraProjection.fieldOfViewY_rad = fovy;
		cameraProjection.nearClipPlane = near_p;
		cameraProjection.farClipPlane = far_p;
		cameraProjection.aspect = aspect_ratio;
		cameraProjection.pixelWidth = width;
		cameraProjection.pixelHeight = height;

		mint::BoundingBoxCorners newBbox;
		if (bboxReceiver.getData(newBbox)) {
			if(newBbox.min != bboxCorners.min || newBbox.max != bboxCorners.max) {
				defaultCameraView = get_camera_view(newBbox);
				bboxCorners = newBbox;
				std::cout << "New Bbox: ("
					<< bboxCorners.min.x << ", "
					<< bboxCorners.min.y << ", "
					<< bboxCorners.min.z << "; "
					<< bboxCorners.max.x << ", "
					<< bboxCorners.max.y << ", "
					<< bboxCorners.max.z << ") "
					<< std::endl;
			}
		}

		// https://stackoverflow.com/questions/70617006/how-to-rotate-an-object-around-a-point-with-glm-opengl-c
		auto rotate_around = [&](float rad, const glm::vec3& point, const glm::vec3& axis) -> glm::mat4
			{
				auto t1 = glm::translate(glm::mat4(1), -point);
				auto r = glm::rotate(glm::mat4(1), rad, axis);
				auto t2 = glm::translate(glm::mat4(1), point);
				return t2 * r * t1;
			};

		defaultCameraView.eyePos = toInterop(glm::vec3(rotate_around(glfwGetTime()*0.001f, glm::vec3(toGlm(defaultCameraView.lookAtPos)), glm::vec3(toGlm(defaultCameraView.camUpDir))) * toGlm(defaultCameraView.eyePos)));

		stereoCameraView.leftEyeView = defaultCameraView;
		stereoCameraView.leftEyeView.eyePos.w = glm::uintBitsToFloat(frame_id);
		stereoCameraView.rightEyeView = defaultCameraView;
		// actually draw different left/right cameras
		stereoCameraView.rightEyeView.eyePos += 0.2*bboxCorners.diagonal();

		data_sender.sendData("StereoCameraViewRelative", stereoCameraView);
		data_sender.sendData("CameraProjection", cameraProjection);

		texture_receiver.receiveTexture();
		auto texture_handle = texture_receiver.m_texture_handle;

		if(width != fbo.m_width || height != fbo.m_height) {
			fbo.resizeTexture(width, height);
		}

		// render into custom framebuffer
		fbo.bind();
		glViewport(0, 0, width, height);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		glUseProgram(program);

		unsigned int binding_point = 0;
		glActiveTexture(GL_TEXTURE0 + binding_point);
		glBindTexture(GL_TEXTURE_2D, texture_handle);
		glUniform1i(uniform_texture_location, binding_point);

		glUniform2i(uniform_texture_size_location, width, height); // set it manually

		quad.bind();
		glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
		quad.unbind();

		fbo.unbind();
		fbo.blitTexture();

		glfwSwapBuffers(window);
		glfwPollEvents();
	}

	data_sender.stop();
	bboxReceiver.stop();

	fbo.destroy();
	texture_receiver.destroy();

	quad.destroy();

	glfwDestroyWindow(window);
	glfwTerminate();
	exit(EXIT_SUCCESS);
}